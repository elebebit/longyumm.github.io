---
layout:     post                    # 使用的布局（不需要改）
title:      H264基本原理               # 标题 
subtitle:   总结                     #副标题
date:       2019-07-09              # 时间
author:     longyu                      # 作者
header-img: img/in_post/20190709/H264.png    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - H264
    - 视频编码
---

## H264基本原理

在视频编码中，一段视频由多个连续的帧构成。通常在一段时间内，相邻的几帧画面中，有差别的像素点大概占10%左右，亮度差值变化不超过2%，而色度差值的变化只有1%以内。所以对于一段变化不大的图像画面，可以先编码出一个完整的图像帧A，随后的B帧就不编码全部图像，只编码与A帧的差异部分，这样B帧编码后的大小只有完整帧A的10%。B帧之后的C帧也可以只编码其与B帧的差异部分，便这样一直循环下去。这一段图像，我们可以将其称为一段序列（序列就是有相同特点的一段数据），也称为一个GOP，当某个图像与之前的图像变化（差别）很大，无法参考前面的帧来生成，则结束上一个队列，开始下一段队列，也就是对这个图像生成一个完整帧A1，随后的图像就参考A1生成，只写入与A1的差别内容。

### 视频编码基础概念

#### IBP

经过压缩后的帧分为I帧，B帧，P帧
    
- I帧：关键帧，采用帧内压缩技术。这一帧包含完整画面，解码时只需要本帧数据就可以完成
- P帧：前向参考帧，在压缩时，只参考前面已经处理的帧。采用帧音压缩技术。P帧表示的是这一帧和之前的一个关键帧（或者P帧）的差别，解码时需要用到之前缓存的画面叠加上本帧定义的差别，生成最终画面。（也就是差别帧，P帧没有完整画面数据，只有与前一帧的画面差别数据）
- B帧：双向参考帧，在压缩时，它既参考前面的帧，也参考后面的帧。采用帧间压缩技术。B帧记录的是本帧与前后的差别（四种情况）。要解码B帧，必须取得之前的缓存画面，也需要解码之后的画面。通过前后画面的与本帧数据的叠加取得最终的画面。B帧压缩率高，解码时CPU耗费大。

I帧采用帧内预测编码。P帧仅仅使用前一个现实的基准帧来编码。B帧同时使用前一个显示帧和未来帧作为基准帧进行编码。实际编码中，编码顺序如下Fig.1。编码器编码一个I帧，然后向前（未编码的帧方向）跳过几个帧，用编码I帧作为基准帧对一个未来的P帧进行编码，然后跳回到I帧之后的下一个帧。编码的I帧和P帧直接的帧被编码为B帧。之后，编码器会再次跳过几个帧，使用第一个P帧未做基准帧编码另外一个P帧，然后再次跳回，用B帧填充显式序列中的空隙。这个过程不断重复，每12到15个P帧和B帧内插入一个新的I帧。P帧由前一个I帧或P帧图像来预测，而B帧有前后两个P帧或一个I帧一个P帧来预测，因而编解码和帧的显式序列有所不同。

<center><img src="https://www.laomao.world/img/IPB.jpg" width="50%" height="50%" /></center>
<center> Fig.1 IPB帧编码和显式顺序 </center>

**I帧、B帧、P帧特点：**

I帧：

    1) 全帧压缩编码帧。它将全帧图像信息进行JPEG压缩编码及传输；
    2) 不需要参考其他画面而生成，解码时仅用I帧的数据就可重构完整图像；
    3) 描述了图像背景和运动主体的详情；
    4) 是P帧和B帧的参考帧，质量影响到同组其他帧；
    5) 在一个GoP中只有一个，是GoP的基础帧；
    6) 不需要考虑运动矢量；
    7) 所占数据的信息量比较大。

B帧：

    1）B帧是由前面的I帧或P帧和后面的P帧来进行预测的；
    2）B帧传送的是它与前面的I或P帧和后面的P帧之间的预测误差及运动矢量；
    3）B帧是双向预测编码帧；
    4）B帧压缩比最高，因为它只反映参考帧间运动主体的变化情况,预测比较准确;加大B帧的数量可以有效地提高视频数据的压缩比，但是在实时互动的环境下，过多的B帧会引起延时，因为B帧会过分的依赖于前后帧，在网络好的环境下，可以正常的传输帧，这样没有什么问题，但是在网络不好的时候，B帧会等待其他帧到来，会引起延时；
    5）B帧不是参考帧，不会造成解码错误的扩散。

P帧：

    1）P帧是I帧后面相隔1~2帧的编码帧；
    2）P帧采用运动补偿的方法传送它与前面的I或P帧的差值及运动矢量（预测误差）；
    3）解码时必须将I帧中的预测值与预测误差求和后才能重构完整的P帧图像;
    4）P帧属于前向预测的帧间编码。它只参考前面最靠近它的I帧或P帧；
    5）P帧可以是其后面P帧的参考帧,也可以是其前后的B帧的参考帧;
    6）由于P帧是参考帧,它可能造成解码错误的扩散;
    7）由于是差值传送，P帧的压缩比较高。




#### IDR

IDR(Instantaneous Decoding Refresh) ——即时解码刷新
I帧和IDR帧都是使用帧内预测的，在编码和解码中为了方便，要将首个I帧与其他I帧区别开，所以将首个I帧定义为IDR，这样就方便控制编码和解码流程。IDR帧的作用是立刻刷新，使错误不至于传播，从IDR帧开始，重新计算一个新的序列开始编码。而I帧不具有随机访问的能力，此功能由IDR承担。IDR会导致DPB（Decoded Picture Buffer 参考帧列表）清空，而I帧不会。

IDR图像一定是I图像，但I图像不一定是IDR图像。一个序列中可以有许多的I-frame，I图像之后的图像可以引用I图像之间的图像做运动参考。

对于IDR帧而言，在IDR帧之后的所有帧都不能引用任何IDR之前的帧的内容。于此相反，对于普通的I-帧来说，位于之后的B和P-frame都可以引用位于普通I-frame之前的I-frame。从随机存取的视频流中，播放器永远可以从一个IDRframe播放，因为在它之后没有任何帧引用之前的帧。但是，不能在一个没有IDR帧的视频中从任意点开始播放，因为后面的帧总是会引用前面的帧。

#### GOP

GOP（Group of Picture）。通常意义上的GoP由I帧开始，到下一个I帧之前的帧结束。一个GoP组内的所有帧独立于其之前的GoP和其之后的GoP。但是在实际应用中，为了得到更大的压缩比，出现的Open GoP和Closed GoP之分。

<center><img src="https://www.laomao.world/img/GOP.png" width="50%" height="50%" /></center>
<center> Fig.2 GOP </center>

- **Closed GoP:**传统意义的GoP，即一个GoP内的所有帧不能依赖之前或之后的GoP，只能依赖该GoP内的帧。
- **Open GoP:**GoP以1个或多个B帧开始，这些B帧参考前一个GoP最后的P帧和当前GoP的第一个I帧进行编码，也可认为这些B帧是前一个GoP不以P帧结尾，而是以B帧结尾。这些B帧参考所在GoP的最后一个P帧及下一个GoP的起始I帧进行编码。Open GoP比Closed GoP扩展出1个或者多个B帧，具有更高的压缩率。


#### SPS 和 PPS

SPS即Sequence Paramater Set，又称为序列参数集。SPS中保存了一组编码序列（Coded Video Sequence）的全局参数。存放包括：帧数、参考帧数目、解码图像尺寸、帧场编码模式选择标志等。所谓的编码视频序列即原始视频的一帧一帧的像素数据经过编码之后的数据组成的序列。而每一帧的编码后数据所依赖的参数保存于图像参数集中。 

H264中另外一个重要的参数集为图像参数集（Picture Parameter Set, PPS）。和图像相关的参数集，存放包括：熵编码模式选择标志、片组数目、初始量化参数和去方块滤波系数调整标志等。通常情况下，PPS类似于SPS，在H264的裸码流中单独保存在一个NAL Unit中，只是PPS NAL Unit的nal_unit_type值为8；而在封装格式中，PPS通常与SPS一起，保存在视频文件的文件头中。

**在一组帧之前，首先要收到SPS 和 PPS ，不然的话是无法解码的。这两组数据划分为I帧，是不能丢的。**

一般情况下，**SPS和PPS的NAL Unit通常位于整个码流的起始位置**。但在某些特殊情况下，在码流中间也可能出现这两种结构，主要原因如下：

- 解码器需要在码流中间开始解码
- 编码器在编码过程中改变了码流的参数（如图像分辨率）

#### 花屏和卡顿

（1）如果在GOP分组中的P帧丢失，会造成解码端的图像发生错误。这就是花屏。GOP一组帧呈现出的连贯效果，由于P帧丢失，它需要更新的部分就没有，所以无法正常呈现。

（2）为了解决花屏的问题发生，我们可以将丢失P帧或I帧的GOP丢掉（包含其中的所有帧），直到下一个I帧再重新刷新图像。由于帧丢失，出现卡顿。 

---

### H264编码原理

#### H264压缩编码技术

H264压缩编码技术主要采用以下几种方法对视频数据进行压缩。包括：

- 帧内预测压缩，解决的是空域数据冗余问题。该帧中的数据，比如：宽、高、颜色、光亮等，有一些人眼不敏感的，可以删除掉的，这称之为冗余数据。
- 帧间预测压缩（运动估计与补偿），解决的事时域数据冗余问题。比如：一个摄像头获得了许多帧数据，帧间的相关性是很强的，所以帧与帧之间会有许多的可以删除的数据。
- 整数离散余弦变换（DCT），将空间上的相关性变为频域上无关的数据然后量化
- CABAC压缩，也称无损压缩。

#### 宏块的划分

**H.264中块，宏块，片，图像的关系:**
块->宏块(MB)->片(Slice)->片组->图像(picture),如下图

<center><img src="https://upload-images.jianshu.io/upload_images/1223522-2d904181c714214b?imageMogr2/auto-orient/strip%7CimageView2/2/w/728/format/webp" width="70%" height="70%" /></center>



H264的基本原理是通过摄像头采集到的视频帧（按每秒30帧算），被送到H264编码器的缓冲区中。编码器先要为每一幅图片划分宏块。

以下图为例：

<center><img src="https://ai2-s2-public.s3.amazonaws.com/figures/2017-08-08/0537509fbf1a40537294ffb7bf074bc10e73877f/2-Figure2-1.png" width="50%" height="50%" /></center>
<center> Fig.3 Macroblock </center>

**划分宏块**

H264默认是使用16x16大小的区域作为一个宏块，也可以划分为8x8大小。

划分好宏块后，计算宏块的像素值。

<center><img src="https://pic1.zhimg.com/80/v2-fb726b6482ffac1e219f487e4b3fa948_hd.jpg" width="50%" height="50%" /></center>

以此类推，计算一幅图像中每个宏块的像素值，所有宏块都处理完后，如下。

<center><img src="https://pic4.zhimg.com/80/v2-7aee71b2cecc08c801773aa2e59c774f_hd.jpg" width="50%" height="50%" /></center>

**划分子块**

H264对比较平坦的图像使用16x16大小的宏块。但为了更高的压缩率，还可以在16x16的宏块上更划分出更小的子块。子块的大小可以是8x16,16x8,8x8,4x8,8x4,4x4等，如下图

<center><img src="https://media-vcodex-com.s3-eu-west-1.amazonaws.com/media/uploads/interpredict/h.264_interpredict_1.png" width="50%" height="50%" /></center>

#### 帧分组（GOP）

对于视频数据主要有两类数据冗余，一类是时间上的数据冗余，另一类是空间上的数据冗余。其中时间上的数据冗余是最大的。

假设摄像头每秒抓取30帧，这30帧的数据大部分情况下都是相关联的。也有可能不止30帧的数据，可能几十帧，上百帧的数据都是关联特别紧密的。H264编码器会按顺序，每次取两幅相邻的帧进行宏块比较，计算两帧的相似度。

通过宏块扫描和宏块搜索可以发现这两个帧的关联度是非常高的。进而发现这一组帧的关联度都是非常高的。因此，这几帧就可以划分为一组。其算法是：**在相邻几幅图像画面中，一般有差别的像素只有10%以内的点，亮度差值变化不超过2%，而色度差值的变化只有1%以内，我们认为这样的图可以分到一组。**

在这样一组帧中，经过编码后，我们只保留第一帧的完整数据，其他帧都通过参考上一帧计算出来。我们称第一帧为IDR/I帧，其他帧称为P/B帧，这样编码后的数据帧组我们称为GOP。

#### 运动估计与补偿（帧间压缩技术）

在H264编码器中将帧分组后，就要计算组内物体的运动矢量。

H264编码器首先按顺序从缓冲区取出两帧视频数据，然后进行宏块扫描。当发现其中一幅图片中有物体时，就在另一幅图的临近位置（搜索窗口中）进行搜索。如果此时在另外一幅图中找到该物体，那么就可以计算出物体的运动矢量了。

运动矢量计算出来后，将相同部分减去，就得到了补偿数据。我们最终只需要将补偿数据进行压缩保存，以后在解码时就可以恢复原图了。压缩补偿后的数据只需要记录很少的一点数据。运动矢量与补偿也称为 **帧间压缩技术**，它解决的是视频帧在时间上的数据冗余。除了帧间压缩，帧内也要进行数据压缩，帧内数据压缩解决的是空间上的数据冗余。

#### 帧内预测

人眼对图像都要一个识别度，对低频的亮度很敏感，对高频的亮度不太敏感。所以基于研究，可以将一幅图像中人眼不敏感的数据去除掉。这样就提出了帧内预测技术。针对于I帧。

H264的帧内压缩与JPEG很相似。一幅图像被划分好宏块后，对每个宏块进行9种模式的预测（H265有33种）。具体要使用哪种预测模式，是选择与原图最接近的一种预测模式。

下面这幅图是对整幅图中的每个宏块利用九种预测模式进行预测的过程。

<center><img src="https://pic1.zhimg.com/80/v2-188ee8d2d45a9378e57af558348bed68_hd.jpg
" width="50%" height="50%" /></center>

帧内预测后的图像与原始图像的对比如下

<center><img src="https://pic1.zhimg.com/80/v2-ea88af6553af906265a03aab1298516c_hd.jpg
" width="50%" height="50%" /></center>

然后，将原始图像与帧内预测后的图像相减得残差值。

<center><img src="https://pic1.zhimg.com/80/v2-a6def4f84eaa709355c8698445990050_hd.jpg
" width="50%" height="50%" /></center>

再将我们之前得到的 **预测模式信息数据**和 **刚得到的图像的残差值**一起保存起来，这样我们就可以在解码时恢复原图了。效果如下。在解码时，我们可以通过预测模式信息恢复出一幅预测的图，然后根据图像的残差值，做加法运算得到原图：

<center><img src="https://pic1.zhimg.com/80/v2-1e9754fd5982573a86e67ee53954d3cc_hd.jpg
" width="50%" height="50%" /></center>

经过帧内与帧间的压缩后，虽然数据有大幅减少，但还有优化的空间。

#### 对残差数据做DCT

可以将残差数据做整数离散余弦变换（DCT），去掉数据的相关性，进一步压缩数据。如下图所示，左侧为原数据的宏块，右侧为计算出的残差数据的宏块。

<center><img src="https://pic3.zhimg.com/80/v2-7148ca9bc0e403a073a77f947aa5cee2_hd.jpg
" width="50%" height="50%" /></center>

将残差数据宏块进行 DCT 转换。

#### CABAC

CABAC属于无损压缩。

无损压缩比较熟悉的是哈夫曼编码，给高频的词一个短码，低频的词一个长码而达到数据压缩的目的。
MPEG-2中使用的VLC就是这种算法，以A-Z为例，A属于高频数据，Z属于低频数据。

<center><img src="https://pic3.zhimg.com/80/v2-99d4f60c6adaa06d90f8ccc4a0330b8e_hd.jpg
" width="50%" height="50%" /></center>

CABAC也是给高频数据短码，给低频数据长码。同时还会根据上下文相关性进行压缩，这种方式又比VLC高效很多。其效果如下：

<center><img src="https://pic4.zhimg.com/80/v2-c31ee65e0e23c79485006e37bf955913_hd.jpg
" width="50%" height="50%" /></center>

**本文主要内容：**

- 宏块的划分
- 帧内压缩技术原理
- 帧间压缩技术原理
- DCT
- CABAC压缩原理




### Reference

[图像和流媒体-I帧，B帧，P帧，IDR帧的区别](https://blog.csdn.net/qq_29350001/article/details/73770702?locationNum=6&fps=1)

[数字视频编码IPB帧编码序列，显示序列以及GOP相关知识](https://www.cnblogs.com/wangyujoy/archive/2012/12/12/2814803.html)

[H264的基本原理](https://zhuanlan.zhihu.com/p/31056455)








































